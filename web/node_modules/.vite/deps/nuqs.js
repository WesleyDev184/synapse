"use client";
import {
  debug,
  error,
  renderQueryString,
  useAdapter,
  useAdapterDefaultOptions,
  useAdapterProcessUrlSearchParams,
  warn
} from "./chunk-Y4O7FY35.js";
import {
  require_react
} from "./chunk-6U6HN6A3.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/.pnpm/nuqs@2.7.3_@tanstack+react-router@1.134.15_react-dom@19.2.0_react@19.2.0__react@19.2.0__react@19.2.0/node_modules/nuqs/dist/debounce-C70-rAd_.js
var import_react = __toESM(require_react(), 1);
function getDefaultThrottle() {
  if (typeof window === "undefined") return 50;
  if (!Boolean(window.GestureEvent)) return 50;
  try {
    const match = navigator.userAgent?.match(/version\/([\d\.]+) safari/i);
    return parseFloat(match[1]) >= 17 ? 120 : 320;
  } catch {
    return 320;
  }
}
function throttle(timeMs) {
  return {
    method: "throttle",
    timeMs
  };
}
function debounce(timeMs) {
  return {
    method: "debounce",
    timeMs
  };
}
var defaultRateLimit = throttle(getDefaultThrottle());
function isAbsentFromUrl(query) {
  return query === null || Array.isArray(query) && query.length === 0;
}
function write(serialized, key, searchParams) {
  if (typeof serialized === "string") searchParams.set(key, serialized);
  else {
    searchParams.delete(key);
    for (const v of serialized) searchParams.append(key, v);
    if (!searchParams.has(key)) searchParams.set(key, "");
  }
  return searchParams;
}
function createEmitter() {
  const all = /* @__PURE__ */ new Map();
  return {
    on(type, handler) {
      const handlers = all.get(type) || [];
      handlers.push(handler);
      all.set(type, handlers);
      return () => this.off(type, handler);
    },
    off(type, handler) {
      const handlers = all.get(type);
      if (handlers) all.set(type, handlers.filter((h) => h !== handler));
    },
    emit(type, event) {
      all.get(type)?.forEach((handler) => handler(event));
    }
  };
}
function timeout(callback, ms, signal) {
  function onTick() {
    callback();
    signal.removeEventListener("abort", onAbort);
  }
  const id = setTimeout(onTick, ms);
  function onAbort() {
    clearTimeout(id);
    signal.removeEventListener("abort", onAbort);
  }
  signal.addEventListener("abort", onAbort);
}
function withResolvers() {
  const P = Promise;
  if (Promise.hasOwnProperty("withResolvers")) return Promise.withResolvers();
  let resolve = () => {
  };
  let reject = () => {
  };
  return {
    promise: new P((res, rej) => {
      resolve = res;
      reject = rej;
    }),
    resolve,
    reject
  };
}
function compose(fns, final) {
  let next = final;
  for (let i = fns.length - 1; i >= 0; i--) {
    const fn = fns[i];
    if (!fn) continue;
    const prev = next;
    next = () => fn(prev);
  }
  next();
}
function getSearchParamsSnapshotFromLocation() {
  return new URLSearchParams(location.search);
}
var ThrottledQueue = class {
  updateMap = /* @__PURE__ */ new Map();
  options = {
    history: "replace",
    scroll: false,
    shallow: true
  };
  timeMs = defaultRateLimit.timeMs;
  transitions = /* @__PURE__ */ new Set();
  resolvers = null;
  controller = null;
  lastFlushedAt = 0;
  resetQueueOnNextPush = false;
  push({ key, query, options }, timeMs = defaultRateLimit.timeMs) {
    if (this.resetQueueOnNextPush) {
      this.reset();
      this.resetQueueOnNextPush = false;
    }
    debug("[nuqs gtq] Enqueueing %s=%s %O", key, query, options);
    this.updateMap.set(key, query);
    if (options.history === "push") this.options.history = "push";
    if (options.scroll) this.options.scroll = true;
    if (options.shallow === false) this.options.shallow = false;
    if (options.startTransition) this.transitions.add(options.startTransition);
    if (!Number.isFinite(this.timeMs) || timeMs > this.timeMs) this.timeMs = timeMs;
  }
  getQueuedQuery(key) {
    return this.updateMap.get(key);
  }
  getPendingPromise({ getSearchParamsSnapshot = getSearchParamsSnapshotFromLocation }) {
    return this.resolvers?.promise ?? Promise.resolve(getSearchParamsSnapshot());
  }
  flush({ getSearchParamsSnapshot = getSearchParamsSnapshotFromLocation, rateLimitFactor = 1, ...adapter }, processUrlSearchParams) {
    this.controller ??= new AbortController();
    if (!Number.isFinite(this.timeMs)) {
      debug("[nuqs gtq] Skipping flush due to throttleMs=Infinity");
      return Promise.resolve(getSearchParamsSnapshot());
    }
    if (this.resolvers) return this.resolvers.promise;
    this.resolvers = withResolvers();
    const flushNow = () => {
      this.lastFlushedAt = performance.now();
      const [search, error$1] = this.applyPendingUpdates({
        ...adapter,
        autoResetQueueOnUpdate: adapter.autoResetQueueOnUpdate ?? true,
        getSearchParamsSnapshot
      }, processUrlSearchParams);
      if (error$1 === null) {
        this.resolvers.resolve(search);
        this.resetQueueOnNextPush = true;
      } else this.resolvers.reject(search);
      this.resolvers = null;
    };
    const runOnNextTick = () => {
      const timeSinceLastFlush = performance.now() - this.lastFlushedAt;
      const timeMs = this.timeMs;
      const flushInMs = rateLimitFactor * Math.max(0, timeMs - timeSinceLastFlush);
      debug(`[nuqs gtq] Scheduling flush in %f ms. Throttled at %f ms (x%f)`, flushInMs, timeMs, rateLimitFactor);
      if (flushInMs === 0) flushNow();
      else timeout(flushNow, flushInMs, this.controller.signal);
    };
    timeout(runOnNextTick, 0, this.controller.signal);
    return this.resolvers.promise;
  }
  abort() {
    this.controller?.abort();
    this.controller = new AbortController();
    this.resolvers?.resolve(new URLSearchParams());
    this.resolvers = null;
    return this.reset();
  }
  reset() {
    const queuedKeys = Array.from(this.updateMap.keys());
    debug("[nuqs gtq] Resetting queue %s", JSON.stringify(Object.fromEntries(this.updateMap)));
    this.updateMap.clear();
    this.transitions.clear();
    this.options = {
      history: "replace",
      scroll: false,
      shallow: true
    };
    this.timeMs = defaultRateLimit.timeMs;
    return queuedKeys;
  }
  applyPendingUpdates(adapter, processUrlSearchParams) {
    const { updateUrl, getSearchParamsSnapshot } = adapter;
    let search = getSearchParamsSnapshot();
    debug(`[nuqs gtq] Applying %d pending update(s) on top of %s`, this.updateMap.size, search.toString());
    if (this.updateMap.size === 0) return [search, null];
    const items = Array.from(this.updateMap.entries());
    const options = { ...this.options };
    const transitions = Array.from(this.transitions);
    if (adapter.autoResetQueueOnUpdate) this.reset();
    debug("[nuqs gtq] Flushing queue %O with options %O", items, options);
    for (const [key, value] of items) if (value === null) search.delete(key);
    else search = write(value, key, search);
    if (processUrlSearchParams) search = processUrlSearchParams(search);
    try {
      compose(transitions, () => {
        updateUrl(search, options);
      });
      return [search, null];
    } catch (err) {
      console.error(error(429), items.map(([key]) => key).join(), err);
      return [search, err];
    }
  }
};
var globalThrottleQueue = new ThrottledQueue();
function useSyncExternalStores(keys, subscribeKey, getKeySnapshot) {
  const snapshot = (0, import_react.useCallback)(() => {
    const record = Object.fromEntries(keys.map((key) => [key, getKeySnapshot(key)]));
    return [JSON.stringify(record), record];
  }, [keys.join(","), getKeySnapshot]);
  const cacheRef = (0, import_react.useRef)(null);
  if (cacheRef.current === null) cacheRef.current = snapshot();
  return (0, import_react.useSyncExternalStore)((0, import_react.useCallback)((callback) => {
    const off = keys.map((key) => subscribeKey(key, callback));
    return () => off.forEach((unsubscribe) => unsubscribe());
  }, [keys.join(","), subscribeKey]), () => {
    const [cacheKey, record] = snapshot();
    if (cacheRef.current[0] === cacheKey) return cacheRef.current[1];
    cacheRef.current = [cacheKey, record];
    return record;
  }, () => cacheRef.current[1]);
}
var DebouncedPromiseQueue = class {
  callback;
  resolvers = withResolvers();
  controller = new AbortController();
  queuedValue = void 0;
  constructor(callback) {
    this.callback = callback;
  }
  abort() {
    this.controller.abort();
    this.queuedValue = void 0;
  }
  push(value, timeMs) {
    this.queuedValue = value;
    this.controller.abort();
    this.controller = new AbortController();
    timeout(() => {
      const outputResolvers = this.resolvers;
      try {
        debug("[nuqs dq] Flushing debounce queue", value);
        const callbackPromise = this.callback(value);
        debug("[nuqs dq] Reset debounce queue %O", this.queuedValue);
        this.queuedValue = void 0;
        this.resolvers = withResolvers();
        callbackPromise.then((output) => outputResolvers.resolve(output)).catch((error$1) => outputResolvers.reject(error$1));
      } catch (error$1) {
        this.queuedValue = void 0;
        outputResolvers.reject(error$1);
      }
    }, timeMs, this.controller.signal);
    return this.resolvers.promise;
  }
};
var DebounceController = class {
  throttleQueue;
  queues = /* @__PURE__ */ new Map();
  queuedQuerySync = createEmitter();
  constructor(throttleQueue = new ThrottledQueue()) {
    this.throttleQueue = throttleQueue;
  }
  useQueuedQueries(keys) {
    return useSyncExternalStores(keys, (key, callback) => this.queuedQuerySync.on(key, callback), (key) => this.getQueuedQuery(key));
  }
  push(update, timeMs, adapter) {
    if (!Number.isFinite(timeMs)) {
      const getSnapshot = adapter.getSearchParamsSnapshot ?? getSearchParamsSnapshotFromLocation;
      return Promise.resolve(getSnapshot());
    }
    const key = update.key;
    if (!this.queues.has(key)) {
      debug("[nuqs dqc] Creating debounce queue for `%s`", key);
      const queue = new DebouncedPromiseQueue((update$1) => {
        this.throttleQueue.push(update$1);
        return this.throttleQueue.flush(adapter).finally(() => {
          if (this.queues.get(update$1.key)?.queuedValue === void 0) {
            debug("[nuqs dqc] Cleaning up empty queue for `%s`", update$1.key);
            this.queues.delete(update$1.key);
          }
          this.queuedQuerySync.emit(update$1.key);
        });
      });
      this.queues.set(key, queue);
    }
    debug("[nuqs dqc] Enqueueing debounce update %O", update);
    const promise = this.queues.get(key).push(update, timeMs);
    this.queuedQuerySync.emit(key);
    return promise;
  }
  abort(key) {
    const queue = this.queues.get(key);
    if (!queue) return (passThrough) => passThrough;
    debug("[nuqs dqc] Aborting debounce queue %s=%s", key, queue.queuedValue?.query);
    this.queues.delete(key);
    queue.abort();
    this.queuedQuerySync.emit(key);
    return (promise) => {
      promise.then(queue.resolvers.resolve, queue.resolvers.reject);
      return promise;
    };
  }
  abortAll() {
    for (const [key, queue] of this.queues.entries()) {
      debug("[nuqs dqc] Aborting debounce queue %s=%s", key, queue.queuedValue?.query);
      queue.abort();
      queue.resolvers.resolve(new URLSearchParams());
      this.queuedQuerySync.emit(key);
    }
    this.queues.clear();
  }
  getQueuedQuery(key) {
    const debouncedQueued = this.queues.get(key)?.queuedValue?.query;
    if (debouncedQueued !== void 0) return debouncedQueued;
    return this.throttleQueue.getQueuedQuery(key);
  }
};
var debounceController = new DebounceController(globalThrottleQueue);

// node_modules/.pnpm/nuqs@2.7.3_@tanstack+react-router@1.134.15_react-dom@19.2.0_react@19.2.0__react@19.2.0__react@19.2.0/node_modules/nuqs/dist/compare-Br3z3FUS.js
function compareQuery(a, b) {
  if (a === b) return true;
  if (a === null || b === null) return false;
  if (typeof a === "string" || typeof b === "string") return false;
  if (a.length !== b.length) return false;
  return a.every((value, index) => value === b[index]);
}

// node_modules/.pnpm/nuqs@2.7.3_@tanstack+react-router@1.134.15_react-dom@19.2.0_react@19.2.0__react@19.2.0__react@19.2.0/node_modules/nuqs/dist/index.js
var import_react2 = __toESM(require_react());
function createLoader(parsers, { urlKeys = {} } = {}) {
  function loadSearchParams(input, { strict = false } = {}) {
    if (input instanceof Promise) return input.then((i) => loadSearchParams(i, { strict }));
    const searchParams = extractSearchParams(input);
    const result = {};
    for (const [key, parser] of Object.entries(parsers)) {
      const urlKey = urlKeys[key] ?? key;
      const query = parser.type === "multi" ? searchParams.getAll(urlKey) : searchParams.get(urlKey);
      if (isAbsentFromUrl(query)) {
        result[key] = parser.defaultValue ?? null;
        continue;
      }
      let parsedValue;
      try {
        parsedValue = parser.parse(query);
      } catch (error$1) {
        if (strict) throw new Error(`[nuqs] Error while parsing query \`${query}\` for key \`${key}\`: ${error$1}`);
        parsedValue = null;
      }
      if (strict && query && parsedValue === null) throw new Error(`[nuqs] Failed to parse query \`${query}\` for key \`${key}\` (got null)`);
      result[key] = parsedValue ?? parser.defaultValue ?? null;
    }
    return result;
  }
  return loadSearchParams;
}
function extractSearchParams(input) {
  try {
    if (input instanceof Request) return input.url ? new URL(input.url).searchParams : new URLSearchParams();
    if (input instanceof URL) return input.searchParams;
    if (input instanceof URLSearchParams) return input;
    if (typeof input === "object") {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(input)) if (Array.isArray(value)) for (const v of value) searchParams.append(key, v);
      else if (value !== void 0) searchParams.set(key, value);
      return searchParams;
    }
    if (typeof input === "string") {
      if (URL.hasOwnProperty("canParse") && URL.canParse(input)) return new URL(input).searchParams;
      return new URLSearchParams(input);
    }
  } catch {
  }
  return new URLSearchParams();
}
function safeParse(parser, value, key) {
  try {
    return parser(value);
  } catch (error$1) {
    warn("[nuqs] Error while parsing value `%s`: %O" + (key ? " (for key `%s`)" : ""), value, error$1, key);
    return null;
  }
}
function createParser(parser) {
  function parseServerSideNullable(value) {
    if (typeof value === "undefined") return null;
    let str = "";
    if (Array.isArray(value)) {
      if (value[0] === void 0) return null;
      str = value[0];
    }
    if (typeof value === "string") str = value;
    return safeParse(parser.parse, str);
  }
  return {
    type: "single",
    eq: (a, b) => a === b,
    ...parser,
    parseServerSide: parseServerSideNullable,
    withDefault(defaultValue) {
      return {
        ...this,
        defaultValue,
        parseServerSide(value) {
          return parseServerSideNullable(value) ?? defaultValue;
        }
      };
    },
    withOptions(options) {
      return {
        ...this,
        ...options
      };
    }
  };
}
function createMultiParser(parser) {
  function parseServerSideNullable(value) {
    if (typeof value === "undefined") return null;
    return safeParse(parser.parse, Array.isArray(value) ? value : [value]);
  }
  return {
    type: "multi",
    eq: (a, b) => a === b,
    ...parser,
    parseServerSide: parseServerSideNullable,
    withDefault(defaultValue) {
      return {
        ...this,
        defaultValue,
        parseServerSide(value) {
          return parseServerSideNullable(value) ?? defaultValue;
        }
      };
    },
    withOptions(options) {
      return {
        ...this,
        ...options
      };
    }
  };
}
var parseAsString = createParser({
  parse: (v) => v,
  serialize: String
});
var parseAsInteger = createParser({
  parse: (v) => {
    const int = parseInt(v);
    return int == int ? int : null;
  },
  serialize: (v) => "" + Math.round(v)
});
var parseAsIndex = createParser({
  parse: (v) => {
    const int = parseInt(v);
    return int == int ? int - 1 : null;
  },
  serialize: (v) => "" + Math.round(v + 1)
});
var parseAsHex = createParser({
  parse: (v) => {
    const int = parseInt(v, 16);
    return int == int ? int : null;
  },
  serialize: (v) => {
    const hex = Math.round(v).toString(16);
    return (hex.length & 1 ? "0" : "") + hex;
  }
});
var parseAsFloat = createParser({
  parse: (v) => {
    const float = parseFloat(v);
    return float == float ? float : null;
  },
  serialize: String
});
var parseAsBoolean = createParser({
  parse: (v) => v.toLowerCase() === "true",
  serialize: String
});
function compareDates(a, b) {
  return a.valueOf() === b.valueOf();
}
var parseAsTimestamp = createParser({
  parse: (v) => {
    const ms = parseInt(v);
    return ms == ms ? new Date(ms) : null;
  },
  serialize: (v) => "" + v.valueOf(),
  eq: compareDates
});
var parseAsIsoDateTime = createParser({
  parse: (v) => {
    const date = new Date(v);
    return date.valueOf() == date.valueOf() ? date : null;
  },
  serialize: (v) => v.toISOString(),
  eq: compareDates
});
var parseAsIsoDate = createParser({
  parse: (v) => {
    const date = new Date(v.slice(0, 10));
    return date.valueOf() == date.valueOf() ? date : null;
  },
  serialize: (v) => v.toISOString().slice(0, 10),
  eq: compareDates
});
function parseAsStringEnum(validValues) {
  return parseAsStringLiteral(validValues);
}
function parseAsStringLiteral(validValues) {
  return createParser({
    parse: (query) => {
      const asConst = query;
      return validValues.includes(asConst) ? asConst : null;
    },
    serialize: String
  });
}
function parseAsNumberLiteral(validValues) {
  return createParser({
    parse: (query) => {
      const asConst = parseFloat(query);
      if (validValues.includes(asConst)) return asConst;
      return null;
    },
    serialize: String
  });
}
function parseAsJson(validator) {
  return createParser({
    parse: (query) => {
      try {
        const obj = JSON.parse(query);
        if ("~standard" in validator) {
          const result = validator["~standard"].validate(obj);
          if (result instanceof Promise) throw new Error("[nuqs] Only synchronous Standard Schemas are supported in parseAsJson.");
          return result.issues ? null : result.value;
        }
        return validator(obj);
      } catch {
        return null;
      }
    },
    serialize: (value) => JSON.stringify(value),
    eq(a, b) {
      return a === b || JSON.stringify(a) === JSON.stringify(b);
    }
  });
}
function parseAsArrayOf(itemParser, separator = ",") {
  const itemEq = itemParser.eq ?? ((a, b) => a === b);
  const encodedSeparator = encodeURIComponent(separator);
  return createParser({
    parse: (query) => {
      if (query === "") return [];
      return query.split(separator).map((item, index) => safeParse(itemParser.parse, item.replaceAll(encodedSeparator, separator), `[${index}]`)).filter((value) => value !== null && value !== void 0);
    },
    serialize: (values) => values.map((value) => {
      return (itemParser.serialize ? itemParser.serialize(value) : String(value)).replaceAll(separator, encodedSeparator);
    }).join(separator),
    eq(a, b) {
      if (a === b) return true;
      if (a.length !== b.length) return false;
      return a.every((value, index) => itemEq(value, b[index]));
    }
  });
}
function parseAsNativeArrayOf(itemParser) {
  const itemEq = itemParser.eq ?? ((a, b) => a === b);
  return createMultiParser({
    parse: (query) => {
      const parsed = query.map((item, index) => safeParse(itemParser.parse, item, `[${index}]`)).filter((value) => value !== null && value !== void 0);
      return parsed.length === 0 ? null : parsed;
    },
    serialize: (values) => {
      return (Array.isArray(values) ? values : [values]).flatMap((value) => {
        const serialized = itemParser.serialize?.(value) ?? String(value);
        return typeof serialized === "string" ? [serialized] : [...serialized];
      });
    },
    eq(a, b) {
      if (a === b) return true;
      if (a.length !== b.length) return false;
      return a.every((value, index) => itemEq(value, b[index]));
    }
  }).withDefault([]);
}
function createSerializer(parsers, { clearOnDefault = true, urlKeys = {}, processUrlSearchParams } = {}) {
  function serialize(arg1BaseOrValues, arg2values = {}) {
    let [base, search] = isBase(arg1BaseOrValues) ? splitBase(arg1BaseOrValues) : ["", new URLSearchParams()];
    const values = isBase(arg1BaseOrValues) ? arg2values : arg1BaseOrValues;
    if (values === null) {
      for (const key in parsers) {
        const urlKey = urlKeys[key] ?? key;
        search.delete(urlKey);
      }
      if (processUrlSearchParams) search = processUrlSearchParams(search);
      return base + renderQueryString(search);
    }
    for (const key in parsers) {
      const parser = parsers[key];
      const value = values[key];
      if (!parser || value === void 0) continue;
      const urlKey = urlKeys[key] ?? key;
      const isMatchingDefault = parser.defaultValue !== void 0 && value !== null && (parser.eq ?? ((a, b) => a === b))(value, parser.defaultValue);
      if (value === null || (parser.clearOnDefault ?? clearOnDefault ?? true) && isMatchingDefault) search.delete(urlKey);
      else search = write(parser.serialize(value), urlKey, search);
    }
    if (processUrlSearchParams) search = processUrlSearchParams(search);
    return base + renderQueryString(search);
  }
  return serialize;
}
function isBase(base) {
  return typeof base === "string" || base instanceof URLSearchParams || base instanceof URL;
}
function splitBase(base) {
  if (typeof base === "string") {
    const [path = "", ...search] = base.split("?");
    return [path, new URLSearchParams(search.join("?"))];
  } else if (base instanceof URLSearchParams) return ["", new URLSearchParams(base)];
  else return [base.origin + base.pathname, new URLSearchParams(base.searchParams)];
}
function createStandardSchemaV1(parsers, { urlKeys, partialOutput = false } = {}) {
  const serialize = createSerializer(parsers, { urlKeys });
  const load = createLoader(parsers, { urlKeys });
  return { "~standard": {
    version: 1,
    vendor: "nuqs",
    validate(input) {
      try {
        const value = load(serialize(input), { strict: true });
        if (partialOutput) {
          for (const key in value) if (!(key in input)) delete value[key];
        }
        return { value };
      } catch (error$1) {
        return { issues: [{ message: error$1 instanceof Error ? error$1.message : String(error$1) }] };
      }
    }
  } };
}
var emitter = createEmitter();
var defaultUrlKeys = {};
function useQueryStates(keyMap, options = {}) {
  const hookId = (0, import_react2.useId)();
  const defaultOptions = useAdapterDefaultOptions();
  const processUrlSearchParams = useAdapterProcessUrlSearchParams();
  const { history = "replace", scroll = defaultOptions?.scroll ?? false, shallow = defaultOptions?.shallow ?? true, throttleMs = defaultRateLimit.timeMs, limitUrlUpdates = defaultOptions?.limitUrlUpdates, clearOnDefault = defaultOptions?.clearOnDefault ?? true, startTransition: startTransition$1, urlKeys = defaultUrlKeys } = options;
  const stateKeys = Object.keys(keyMap).join(",");
  const resolvedUrlKeys = (0, import_react2.useMemo)(() => Object.fromEntries(Object.keys(keyMap).map((key) => [key, urlKeys[key] ?? key])), [stateKeys, JSON.stringify(urlKeys)]);
  const adapter = useAdapter(Object.values(resolvedUrlKeys));
  const initialSearchParams = adapter.searchParams;
  const queryRef = (0, import_react2.useRef)({});
  const defaultValues = (0, import_react2.useMemo)(() => Object.fromEntries(Object.keys(keyMap).map((key) => [key, keyMap[key].defaultValue ?? null])), [Object.values(keyMap).map(({ defaultValue }) => defaultValue).join(",")]);
  const queuedQueries = debounceController.useQueuedQueries(Object.values(resolvedUrlKeys));
  const [internalState, setInternalState] = (0, import_react2.useState)(() => {
    return parseMap(keyMap, urlKeys, initialSearchParams ?? new URLSearchParams(), queuedQueries).state;
  });
  const stateRef = (0, import_react2.useRef)(internalState);
  debug("[nuq+ %s `%s`] render - state: %O, iSP: %s", hookId, stateKeys, internalState, initialSearchParams);
  if (Object.keys(queryRef.current).join("&") !== Object.values(resolvedUrlKeys).join("&")) {
    const { state, hasChanged } = parseMap(keyMap, urlKeys, initialSearchParams, queuedQueries, queryRef.current, stateRef.current);
    if (hasChanged) {
      debug("[nuq+ %s `%s`] State changed: %O", hookId, stateKeys, {
        state,
        initialSearchParams,
        queuedQueries,
        queryRef: queryRef.current,
        stateRef: stateRef.current
      });
      stateRef.current = state;
      setInternalState(state);
    }
    queryRef.current = Object.fromEntries(Object.entries(resolvedUrlKeys).map(([key, urlKey]) => {
      return [urlKey, keyMap[key]?.type === "multi" ? initialSearchParams?.getAll(urlKey) : initialSearchParams?.get(urlKey) ?? null];
    }));
  }
  (0, import_react2.useEffect)(() => {
    const { state, hasChanged } = parseMap(keyMap, urlKeys, initialSearchParams, queuedQueries, queryRef.current, stateRef.current);
    if (hasChanged) {
      debug("[nuq+ %s `%s`] State changed: %O", hookId, stateKeys, {
        state,
        initialSearchParams,
        queuedQueries,
        queryRef: queryRef.current,
        stateRef: stateRef.current
      });
      stateRef.current = state;
      setInternalState(state);
    }
  }, [Object.values(resolvedUrlKeys).map((key) => `${key}=${initialSearchParams?.getAll(key)}`).join("&"), JSON.stringify(queuedQueries)]);
  (0, import_react2.useEffect)(() => {
    const handlers = Object.keys(keyMap).reduce((handlers$1, stateKey) => {
      handlers$1[stateKey] = ({ state, query }) => {
        setInternalState((currentState) => {
          const { defaultValue } = keyMap[stateKey];
          const urlKey = resolvedUrlKeys[stateKey];
          const nextValue = state ?? defaultValue ?? null;
          const currentValue = currentState[stateKey] ?? defaultValue ?? null;
          if (Object.is(currentValue, nextValue)) {
            debug("[nuq+ %s `%s`] Cross-hook key sync %s: %O (default: %O). no change, skipping, resolved: %O", hookId, stateKeys, urlKey, state, defaultValue, stateRef.current);
            return currentState;
          }
          stateRef.current = {
            ...stateRef.current,
            [stateKey]: nextValue
          };
          queryRef.current[urlKey] = query;
          debug("[nuq+ %s `%s`] Cross-hook key sync %s: %O (default: %O). updateInternalState, resolved: %O", hookId, stateKeys, urlKey, state, defaultValue, stateRef.current);
          return stateRef.current;
        });
      };
      return handlers$1;
    }, {});
    for (const stateKey of Object.keys(keyMap)) {
      const urlKey = resolvedUrlKeys[stateKey];
      debug("[nuq+ %s `%s`] Subscribing to sync for `%s`", hookId, urlKey, stateKeys);
      emitter.on(urlKey, handlers[stateKey]);
    }
    return () => {
      for (const stateKey of Object.keys(keyMap)) {
        const urlKey = resolvedUrlKeys[stateKey];
        debug("[nuq+ %s `%s`] Unsubscribing to sync for `%s`", hookId, urlKey, stateKeys);
        emitter.off(urlKey, handlers[stateKey]);
      }
    };
  }, [stateKeys, resolvedUrlKeys]);
  const update = (0, import_react2.useCallback)((stateUpdater, callOptions = {}) => {
    const nullMap = Object.fromEntries(Object.keys(keyMap).map((key) => [key, null]));
    const newState = typeof stateUpdater === "function" ? stateUpdater(applyDefaultValues(stateRef.current, defaultValues)) ?? nullMap : stateUpdater ?? nullMap;
    debug("[nuq+ %s `%s`] setState: %O", hookId, stateKeys, newState);
    let returnedPromise = void 0;
    let maxDebounceTime = 0;
    let doFlush = false;
    const debounceAborts = [];
    for (let [stateKey, value] of Object.entries(newState)) {
      const parser = keyMap[stateKey];
      const urlKey = resolvedUrlKeys[stateKey];
      if (!parser) continue;
      if ((callOptions.clearOnDefault ?? parser.clearOnDefault ?? clearOnDefault) && value !== null && parser.defaultValue !== void 0 && (parser.eq ?? ((a, b) => a === b))(value, parser.defaultValue)) value = null;
      const query = value === null ? null : (parser.serialize ?? String)(value);
      emitter.emit(urlKey, {
        state: value,
        query
      });
      const update$1 = {
        key: urlKey,
        query,
        options: {
          history: callOptions.history ?? parser.history ?? history,
          shallow: callOptions.shallow ?? parser.shallow ?? shallow,
          scroll: callOptions.scroll ?? parser.scroll ?? scroll,
          startTransition: callOptions.startTransition ?? parser.startTransition ?? startTransition$1
        }
      };
      if (callOptions?.limitUrlUpdates?.method === "debounce" || limitUrlUpdates?.method === "debounce" || parser.limitUrlUpdates?.method === "debounce") {
        if (update$1.options.shallow === true) console.warn(error(422));
        const timeMs = callOptions?.limitUrlUpdates?.timeMs ?? limitUrlUpdates?.timeMs ?? parser.limitUrlUpdates?.timeMs ?? defaultRateLimit.timeMs;
        const debouncedPromise = debounceController.push(update$1, timeMs, adapter);
        if (maxDebounceTime < timeMs) {
          returnedPromise = debouncedPromise;
          maxDebounceTime = timeMs;
        }
      } else {
        const timeMs = callOptions?.limitUrlUpdates?.timeMs ?? parser?.limitUrlUpdates?.timeMs ?? limitUrlUpdates?.timeMs ?? callOptions.throttleMs ?? parser.throttleMs ?? throttleMs;
        debounceAborts.push(debounceController.abort(urlKey));
        globalThrottleQueue.push(update$1, timeMs);
        doFlush = true;
      }
    }
    const globalPromise = debounceAborts.reduce((previous, fn) => fn(previous), doFlush ? globalThrottleQueue.flush(adapter, processUrlSearchParams) : globalThrottleQueue.getPendingPromise(adapter));
    return returnedPromise ?? globalPromise;
  }, [
    stateKeys,
    history,
    shallow,
    scroll,
    throttleMs,
    limitUrlUpdates?.method,
    limitUrlUpdates?.timeMs,
    startTransition$1,
    resolvedUrlKeys,
    adapter.updateUrl,
    adapter.getSearchParamsSnapshot,
    adapter.rateLimitFactor,
    processUrlSearchParams,
    defaultValues
  ]);
  return [(0, import_react2.useMemo)(() => applyDefaultValues(internalState, defaultValues), [internalState, defaultValues]), update];
}
function parseMap(keyMap, urlKeys, searchParams, queuedQueries, cachedQuery, cachedState) {
  let hasChanged = false;
  const state = Object.entries(keyMap).reduce((out, [stateKey, parser]) => {
    const urlKey = urlKeys?.[stateKey] ?? stateKey;
    const queuedQuery = queuedQueries[urlKey];
    const fallbackValue = parser.type === "multi" ? [] : null;
    const query = queuedQuery === void 0 ? (parser.type === "multi" ? searchParams?.getAll(urlKey) : searchParams?.get(urlKey)) ?? fallbackValue : queuedQuery;
    if (cachedQuery && cachedState && compareQuery(cachedQuery[urlKey] ?? fallbackValue, query)) {
      out[stateKey] = cachedState[stateKey] ?? null;
      return out;
    }
    hasChanged = true;
    out[stateKey] = (isAbsentFromUrl(query) ? null : safeParse(parser.parse, query, urlKey)) ?? null;
    if (cachedQuery) cachedQuery[urlKey] = query;
    return out;
  }, {});
  if (!hasChanged) {
    const keyMapKeys = Object.keys(keyMap);
    const cachedStateKeys = Object.keys(cachedState ?? {});
    hasChanged = keyMapKeys.length !== cachedStateKeys.length || keyMapKeys.some((key) => !cachedStateKeys.includes(key));
  }
  return {
    state,
    hasChanged
  };
}
function applyDefaultValues(state, defaults) {
  return Object.fromEntries(Object.keys(state).map((key) => [key, state[key] ?? defaults[key] ?? null]));
}
function useQueryState(key, options = {}) {
  const { parse, type, serialize, eq, defaultValue, ...hookOptions } = options;
  const [{ [key]: state }, setState] = useQueryStates({ [key]: {
    parse: parse ?? ((x) => x),
    type,
    serialize,
    eq,
    defaultValue
  } }, hookOptions);
  return [state, (0, import_react2.useCallback)((stateUpdater, callOptions = {}) => setState((old) => ({ [key]: typeof stateUpdater === "function" ? stateUpdater(old[key]) : stateUpdater }), callOptions), [key, setState])];
}
export {
  createLoader,
  createMultiParser,
  createParser,
  createSerializer,
  createStandardSchemaV1,
  debounce,
  defaultRateLimit,
  parseAsArrayOf,
  parseAsBoolean,
  parseAsFloat,
  parseAsHex,
  parseAsIndex,
  parseAsInteger,
  parseAsIsoDate,
  parseAsIsoDateTime,
  parseAsJson,
  parseAsNativeArrayOf,
  parseAsNumberLiteral,
  parseAsString,
  parseAsStringEnum,
  parseAsStringLiteral,
  parseAsTimestamp,
  throttle,
  useQueryState,
  useQueryStates
};
//# sourceMappingURL=nuqs.js.map
